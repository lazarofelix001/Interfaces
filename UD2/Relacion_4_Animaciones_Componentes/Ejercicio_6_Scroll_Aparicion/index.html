<!doctype html>
<html lang="es">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Relación 4 · Ejercicio 6 · Scroll Aparición</title>
  <link rel="stylesheet" href="css/styles.css">
</head>

<body>
  <main>
    <h1>Animación de aparición por scroll</h1>
    <section class="contenedor-scroll">
      <article class="scroll-item">Bloque 1</article>
      <article class="scroll-item">Bloque 2</article>
      <article class="scroll-item">Bloque 3</article>
      <article class="scroll-item">Bloque 4</article>
    </section>
  </main>

  <script>
    // Seleccionamos todos los elementos que queremos animar al hacer scroll.
    // Cada uno tiene la clase .scroll-item.
    const items = document.querySelectorAll('.scroll-item');

    // Opciones de configuración del IntersectionObserver.
    // threshold: 0.3 significa que el 30% del elemento debe estar visible
    // para que se considere "intersectando" con el viewport.
    const options = {
      threshold: 0.3
    };

    // Creamos el observador. Este objeto "vigila" si un elemento entra o sale del viewport.
    // Le pasamos dos cosas:
    // 1) Una función que se ejecuta cada vez que un elemento observado cambia de estado.
    // 2) Las opciones (options) para indicarle cuándo debe considerarse visible.
    const observer = new IntersectionObserver((entries) => {

      // entries es un array con información de TODOS los elementos observados
      // cuyos estados han cambiado en este momento.
      entries.forEach(entry => {

        // entry.isIntersecting es true cuando el elemento ha entrado en el viewport
        // según el threshold definido.
        if (entry.isIntersecting) {

          // entry.target es el elemento concreto que ha entrado en visión.
          // Al añadir la clase .visible se activa la animación definida en CSS.
          entry.target.classList.add('visible');
        }
      });

    }, options);  // IMPORTANTE: aquí pasamos las opciones al observer

    // Indicamos al observer qué elementos debe vigilar.
    // Cada .scroll-item será monitorizado individualmente.
    items.forEach(item => observer.observe(item));

  </script>
</body>

</html>